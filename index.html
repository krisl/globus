<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - lines - fat</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <script src="http://threejs.org/build/three.min.js"></script>
    <script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/lines/LineSegmentsGeometry.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/lines/LineGeometry.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/lines/LineMaterial.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/lines/LineSegments2.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/utils/GeometryUtils.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/lines/Line2.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/libs/stats.min.js'></script>
    <script src='https://rawgit.com/mrdoob/three.js/dev/examples/js/libs/dat.gui.min.js'></script>
  </head>

  <body>

    <div id="container"></div>

    <div id="info"><a href="https://threejs.org" target="_blank">three.js</a> - fat lines</div>

    <script type="module">
      const GLOBE_RADIUS = 20
      const DEGREE_TO_RADIAN = Math.PI / 180

      function latLonToVec(lat, lng, altitude) {
          const radius = GLOBE_RADIUS + altitude
          const phi = (90 - lat) * DEGREE_TO_RADIAN
          const theta = (lng + 180) * DEGREE_TO_RADIAN

          return new THREE.Vector3(
            - radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.cos(phi),
            radius * Math.sin(phi) * Math.sin(theta)
          )
      }

      const auckland = latLonToVec(-36.848461, 174.763336, 0)
      const wellington = latLonToVec(-41.28664, 174.77557, 0)

      const nelson = latLonToVec(-41.27078, 173.28404, 0)
      const dunedin = latLonToVec(-45.87416, 170.50361, 0)

      const madrid = latLonToVec(40.416775, -3.703790, 0)
      const beijing = latLonToVec(39.913818, 116.363625, 0)
      console.log({auckland, wellington, nelson, dunedin})
      //import * as THREE from '../build/three.module.js';

      //import Stats from './jsm/libs/stats.module.js';

      //import { GUI } from './jsm/libs/dat.gui.module.js';
      //import { OrbitControls } from './jsm/controls/OrbitControls.js';
      //import { Line2 } from './jsm/lines/Line2.js';
      //import { LineMaterial } from './jsm/lines/LineMaterial.js';
      //import { LineGeometry } from './jsm/lines/LineGeometry.js';
      //import { GeometryUtils } from './jsm/utils/GeometryUtils.js';

      var line, renderer, scene, camera, camera2, controls;
      var matLine;
      var stats;
      var gui;

      // viewport
      var insetWidth;
      var insetHeight;

      init();
      animate();

      function init() {

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor( 0x000000, 0.0 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( - 40, 0, 60 );

        camera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );
        camera2.position.copy( camera.position );

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 10;
        controls.maxDistance = 500;


        // Position and THREE.Color Data

        var points = THREE.GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );
        console.log({points})
        //var spline1 = new THREE.CatmullRomCurve3( points.splice(20) );
        //var spline = new THREE.QuadraticBezierCurve3( 
        //  new THREE.Vector3( -10, 0, 0 ),
        //  new THREE.Vector3( 0, 0, 0 ),
        //  new THREE.Vector3( 10, 0, 0 )
        //);
        //var splinex = new THREE.CubicBezierCurve3(
        //  new THREE.Vector3( -10, 0, 0 ),
        //  new THREE.Vector3( -5, 15, 0 ),
        //  new THREE.Vector3( 20, 15, 0 ),
        //  new THREE.Vector3( 10, 0, 0 )
        //);
        //var spline = new THREE.LineCurve3(points[0], points[points.length-1]);

        matLine = new THREE.LineMaterial( {

          color: 0xffffff,
          linewidth: 5, // in pixels
          vertexColors: THREE.VertexColors,
          //resolution:  // to be set by renderer, eventually
          dashed: false

        } );

        function plotPath(start, end) {
          const spline = new THREE.LineCurve3(start, end)
          var divisions = Math.round( 12 * points.length );
          var color = new THREE.Color();
          var positions = [];
          var colors = [];

          for ( var i = 0; i < divisions; i ++ ) {

            var point = spline.getPoint( i / divisions );
            positions.push( point.x, point.y, point.z );

            color.setHSL( i / divisions, 1.0, 0.5 );
            colors.push( color.r, color.g, color.b );

          }


          // Line2 ( LineGeometry, LineMaterial )

          var geometry = new THREE.LineGeometry();
          geometry.setPositions( positions );
          geometry.setColors( colors );

          line = new THREE.Line2( geometry, matLine );
          line.computeLineDistances();
          line.scale.set( 1, 1, 1 );
          scene.add( line );
        }

        plotPath(auckland, madrid);
        plotPath(auckland, wellington);
        plotPath(dunedin, beijing);
        plotPath(nelson, dunedin);
        //const spline = new THREE.LineCurve3(auckland, madrid)
        //const spline2 = new THREE.LineCurve3(nelson, dunedin)

        //

        window.addEventListener( 'resize', onWindowResize, false );
        onWindowResize();

        stats = new Stats();
        document.body.appendChild( stats.dom );

        initGui();

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        insetWidth = window.innerHeight / 4; // square
        insetHeight = window.innerHeight / 4;

        camera2.aspect = insetWidth / insetHeight;
        camera2.updateProjectionMatrix();

      }

      function animate() {

        requestAnimationFrame( animate );

        stats.update();

        // main scene

        renderer.setClearColor( 0x000000, 0 );

        renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

        // renderer will set this eventually
        matLine.resolution.set( window.innerWidth, window.innerHeight ); // resolution of the viewport

        renderer.render( scene, camera );

        // inset scene

        renderer.setClearColor( 0x222222, 1 );

        renderer.clearDepth(); // important!

        renderer.setScissorTest( true );

        renderer.setScissor( 20, 20, insetWidth, insetHeight );

        renderer.setViewport( 20, 20, insetWidth, insetHeight );

        camera2.position.copy( camera.position );
        camera2.quaternion.copy( camera.quaternion );

        // renderer will set this eventually
        matLine.resolution.set( insetWidth, insetHeight ); // resolution of the inset viewport

        renderer.render( scene, camera2 );

        renderer.setScissorTest( false );

      }

      //

      function initGui() {

        gui = new dat.GUI();

        var param = {
          'width (px)': 5,
          'dashed': false,
          'dash scale': 1,
          'dash / gap': 1
        };


        gui.add( param, 'width (px)', 1, 10 ).onChange( function ( val ) {

          matLine.linewidth = val;

        } );

        gui.add( param, 'dashed' ).onChange( function ( val ) {

          matLine.dashed = val;

          // dashed is implemented as a defines -- not as a uniform. this could be changed.
          // ... or THREE.LineDashedMaterial could be implemented as a separate material
          // temporary hack - renderer should do this eventually
          if ( val ) matLine.defines.USE_DASH = ""; else delete matLine.defines.USE_DASH;
          matLine.needsUpdate = true;


        } );

        gui.add( param, 'dash scale', 0.5, 2, 0.1 ).onChange( function ( val ) {

          matLine.dashScale = val;

        } );

        gui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {

          switch ( val ) {

            case '0':
              matLine.dashSize = 2;
              matLine.gapSize = 1;

              break;

            case '1':
              matLine.dashSize = 1;
              matLine.gapSize = 1;

              break;

            case '2':
              matLine.dashSize = 1;
              matLine.gapSize = 2;

              break;

          }

        } );

      }

    </script>

  </body>

</html>
